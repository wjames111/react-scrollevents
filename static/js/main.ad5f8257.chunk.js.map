{"version":3,"sources":["bell.svg","react-scrollevents.js","App.js","index.js"],"names":["module","exports","ScrollEvents","props","state","allTriggerElements","triggersPlaystate","indicatorPosition","scrollingContainer","handleScroll","bind","checkTriggers","debounceScroll","isDebounce","debounce","debounceAmount","trailing","leading","this","triggerElements","scrollContainer","indicatorPlacement","calcIndicatorPosition","parseInt","window","innerHeight","checkTypeOfSelector","element","document","querySelector","getSelector","makeElementsArray","Array","isArray","getScrollContainer","current","initTriggerPlaystate","getTriggerElements","map","push","setState","addEventListener","removeEventListener","elemIdx","scrollPosition","playState","isReplayable","onScrollYCallback","elementHeight","offsetHeight","progress","getBoundingClientRect","top","updatetriggersPlaystate","value","newPlaystate","Object","assign","sendCallBack","triggeredAction","setCalbck","calbck","start","end","triggersAmnt","length","scrollTop","isIndicator","customComponent","indicatorStyles","trigger","position","height","width","backgroundColor","right","zIndex","className","style","Component","defaultProps","App","messageData","opacity","transform","messageAlerts","notifyAlert","color","React","createRef","forEach","message","onScrollY","elemInx","action","animateProgress","num","Math","round","opacAnim","scaleAnim","scaleTransCSS","getMessages","updatedAlerts","alertSize","alertColor","alertStyle","ref","alt","src","bell","key","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.ad5f8257.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/bell.877d82b3.svg\";","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport debounce from 'lodash/debounce';\n\nclass ScrollEvents extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      allTriggerElements: [],\n      triggersPlaystate: [],\n      indicatorPosition: '50%',\n      scrollingContainer: 'body',\n    };\n\n    this.handleScroll = this.handleScroll.bind(this);\n    this.checkTriggers = this.checkTriggers.bind(this);\n\n    //  adds reference for removing listener, applies debounce from props\n    this.debounceScroll = props.isDebounce\n      ? debounce(this.handleScroll, props.debounceAmount, {\n        trailing: true,\n        leading: true,\n      })\n      : this.handleScroll;\n  }\n\n  componentDidMount() {\n    const { triggerElements, scrollContainer, indicatorPlacement } = this.props;\n\n    //  finds location of indicator relative to viewport\n    const calcIndicatorPosition = (parseInt(indicatorPlacement, 10) / 100) * window.innerHeight;\n    const getSelector = (element) => document.querySelector(element);\n\n    //  allows props to be a selector or ref\n    const checkTypeOfSelector = (element) => {\n      if (typeof element === 'string') {\n        return getSelector(element);\n      }\n\n      return element;\n    };\n\n    //  map a single trigger or multiple triggers with same function\n    const makeElementsArray = Array.isArray(triggerElements) ? triggerElements : [triggerElements];\n\n    const getScrollContainer = scrollContainer.current ? scrollContainer.current\n      : checkTypeOfSelector(scrollContainer);\n\n    const initTriggerPlaystate = [];\n\n    const getTriggerElements = makeElementsArray.map((element) => {\n      //  keeps reference for triggered elements\n      initTriggerPlaystate.push(false);\n      return checkTypeOfSelector(element);\n    });\n\n    this.setState({\n      allTriggerElements: getTriggerElements,\n      triggersPlaystate: initTriggerPlaystate,\n      indicatorPosition: calcIndicatorPosition,\n      scrollingContainer: getScrollContainer,\n    });\n\n    getScrollContainer.addEventListener('scroll', this.debounceScroll, true);\n  }\n\n  componentWillUnmount() {\n    const { scrollingContainer } = this.state;\n    scrollingContainer.removeEventListener('scroll', this.debounceScroll, true);\n  }\n\n  checkTriggers(elemIdx, scrollPosition) {\n    const { allTriggerElements, triggersPlaystate } = this.state;\n    const { isReplayable, onScrollYCallback } = this.props;\n    const element = allTriggerElements[elemIdx].current || allTriggerElements[elemIdx];\n    const elementHeight = element.offsetHeight;\n    const elementTop = element.getBoundingClientRect().top;\n\n    //  get percentage of trigger element scrolled\n    const progress = ((scrollPosition - elementTop) / elementHeight) * 100;\n\n    const updatetriggersPlaystate = (value) => {\n      const newPlaystate = Object.assign([], triggersPlaystate, {\n        [elemIdx]: value,\n      });\n\n      this.setState({\n        triggersPlaystate: newPlaystate,\n      });\n    };\n\n    //  notifies parent component of triggered events\n    const sendCallBack = (triggeredAction) => {\n      const calbck = onScrollYCallback;\n      let setCalbck;\n\n      switch (triggeredAction) {\n        case 'start':\n          setCalbck = calbck.start;\n          break;\n        case 'progress':\n          setCalbck = calbck.progress;\n          break;\n        case 'end':\n          setCalbck = calbck.end;\n          break;\n        default:\n          setCalbck = null;\n          break;\n      }\n\n      (() => (typeof onScrollYCallback === 'function' ? onScrollYCallback(elemIdx, triggeredAction, progress)\n\n      //  && avoids error if undefined callback invoked\n        : setCalbck && setCalbck(element, progress)))();\n    };\n\n    const updateTriggered = (triggeredAction, playState) => {\n      sendCallBack(triggeredAction);\n      updatetriggersPlaystate(playState);\n    };\n\n    if (progress >= 0 && progress <= 100 && triggersPlaystate[elemIdx] !== null) {\n      if (triggersPlaystate[elemIdx] === false) {\n        updateTriggered('start', true);\n      }\n\n      sendCallBack('progress');\n    } else if (triggersPlaystate[elemIdx]) {\n      // updateTriggered('end', false);\n      sendCallBack('end');\n\n      // adds null for elements already animated but not replayable\n      const played = isReplayable ? false : null;\n      updatetriggersPlaystate(played);\n    }\n  }\n\n  handleScroll() {\n    const { allTriggerElements, indicatorPosition, scrollingContainer } = this.state;\n    const triggersAmnt = allTriggerElements.length;\n\n    if (!triggersAmnt) {\n      //  once all elements removed (line 131) kill listener\n      scrollingContainer.removeEventListener('scroll', this.debounceScroll, true);\n    }\n\n    const scrollPosition = indicatorPosition + scrollingContainer.scrollTop;\n\n    for (let elemIdx = 0; elemIdx < triggersAmnt; elemIdx += 1) {\n      this.checkTriggers(elemIdx, scrollPosition);\n    }\n  }\n\n  render() {\n    const {\n      indicatorPlacement, isIndicator, customComponent, indicatorStyles,\n    } = this.props;\n\n    const trigger = {\n      position: 'fixed',\n      height: '3px',\n      width: '10vw',\n      backgroundColor: 'green',\n      top: `${parseInt(indicatorPlacement, 10)}vh`,\n      right: 0,\n      zIndex: 100,\n\n      //  custom styles here + will overide\n      ...indicatorStyles,\n    };\n\n    return (\n      <div\n        className=\"indicator\"\n\n        // remove styles for nested components\n        style={!customComponent && isIndicator ? trigger : {}}\n      >\n        {customComponent}\n      </div>\n    );\n  }\n}\n\nScrollEvents.defaultProps = {\n  scrollContainer: 'body',\n  indicatorPlacement: '50vh',\n  isIndicator: true,\n  isReplayable: true,\n  debounceAmount: 15,\n  customComponent: null,\n  indicatorStyles: {},\n  isDebounce: false,\n};\n\nScrollEvents.propTypes = {\n  scrollContainer: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.func,\n    PropTypes.shape({ current: PropTypes.instanceOf(Element) }),\n  ]),\n  indicatorPlacement: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  isIndicator: PropTypes.bool,\n  isReplayable: PropTypes.bool,\n  debounceAmount: PropTypes.number,\n  triggerElements: PropTypes.oneOfType([PropTypes.string, PropTypes.array]).isRequired,\n  onScrollYCallback: PropTypes.oneOfType([PropTypes.objectOf(PropTypes.func), PropTypes\n    .func]).isRequired,\n  customComponent: PropTypes.element,\n  indicatorStyles: PropTypes.objectOf(PropTypes.string),\n  isDebounce: PropTypes.bool,\n};\n\nexport default ScrollEvents;\n","import React, { Component } from 'react';\nimport './App.css';\nimport ScrollEvents from './react-scrollevents';\nimport bell from './bell.svg';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      messageData: [['messageOne', { opacity: 0, transform: 'scale(1)' }, 'Lorem ipsum aute officia ut aute ut dolor exercitation tempor pariatur nisi sit.'], ['messageTwo', { opacity: 0, transform: 'scale(1)' }, 'Exercitation et quis ea fugiat voluptate sit occaecat sint dolor.'], ['messageThree', { opacity: 0, transform: 'scale(1)' }, 'Voluptate magna proident aliqua cupidatat fugiat cillum sint reprehenderit.'], ['messageFour', { opacity: 0, transform: 'scale(1)' }, 'Veniam culpa nisi occaecat ut ex in adipisicing nulla aute consequat.'], ['messageFive', { opacity: 0, transform: 'scale(1)' }, 'Lorem ipsum in nostrud proident consequat est ea minim amet nostrud.'], ['messageSix', { opacity: 0, transform: 'scale(1)' }, 'Lorem ipsum dolor est excepteur sint eiusmod proident cillum mollit nisi enim ut consectetur officia excepteur consequat.'], ['messageSeven', { opacity: 0, transform: 'scale(1)' }, 'Ad laboris commodo non ad aliquip id fugiat dolor do in consectetur in ea deserunt incididunt reprehenderit.']],\n      messageAlerts: 0,\n      notifyAlert: { color: '#b5b9c1', transform: 'scale(1)' },\n    };\n\n    this.scrollContainer = React.createRef();\n\n    this.state.messageData.forEach((message) => {\n      this[`messageRef${message[0]}`] = React.createRef();\n    });\n\n    this.onScrollY = this.onScrollY.bind(this);\n  }\n\n  onScrollY(elemInx, action, progress) {\n    const { messageData, messageAlerts } = this.state;\n\n    const animateProgress = (num) => {\n      const endValue = parseInt(num, 10);\n      const progressRounded = Math.round(progress);\n      const frameAmount = (endValue / 100) * progressRounded;\n      return frameAmount;\n    };\n\n    const opacAnim = animateProgress(1);\n    const scaleAnim = animateProgress(1.75);\n    const scaleTransition = progress < 50 ? 1 - (scaleAnim / 10) : 1 + (scaleAnim / 10);\n    const scaleTransCSS = `scale(${scaleTransition})`;\n    const getMessages = [...messageData];\n    getMessages[elemInx][1] = { opacity: opacAnim, transform: scaleTransCSS };\n\n    const checkAlert = () => {\n      if (action === 'end') {\n        if (progress > 90) {\n          return 1;\n        }\n\n        if (messageAlerts) {\n          return -1;\n        }\n\n        return 0;\n      }\n\n      return 0;\n    };\n\n    const newAlerts = checkAlert();\n    const updatedAlerts = messageAlerts + newAlerts;\n    const alertSize = updatedAlerts > messageAlerts ? { transform: 'scale(1.2)' } : { transform: 'scale(1)' };\n    const alertColor = updatedAlerts > 0 ? { color: 'red' } : { color: '#b5b9c1' };\n    const alertStyle = { ...alertSize, ...alertColor };\n\n    this.setState({\n      messageData: getMessages,\n      messageAlerts: updatedAlerts,\n      notifyAlert: alertStyle,\n    });\n  }\n\n  render() {\n    const { messageData, messageAlerts, notifyAlert } = this.state;\n    return (\n      <div>\n        <div ref={this.scrollContainer} className=\"app\">\n          <div className=\"app-container\">\n            <div className=\"app-nav\">\n              <img alt=\"notification bell\" className=\"app-nav-bell\" src={bell} />\n              <span className=\"app-nav-header\">notifications</span>\n              <span className=\"app-nav-list\" style={notifyAlert}>{messageAlerts}</span>\n            </div>\n            {\n              messageData.map((message) => <div key={message[0]} ref={this[`messageRef${message[0]}`]} style={message[1]} className=\"messages\">{message[2]}</div>)\n            }\n          </div>\n        </div>\n        <ScrollEvents\n          triggerElements={messageData.map((message) => this[`messageRef${message[0]}`])}\n          onScrollYCallback={this.onScrollY}\n          scrollContainer={this.scrollContainer}\n          isIndicator\n          indicatorPlacement=\"70vh\"\n          indicatorStyles={{ height: '1vh', backgroundColor: 'blue' }}\n          isReplayable\n          isDebounce={false}\n          debounceAmount\n          customComponent={null}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}